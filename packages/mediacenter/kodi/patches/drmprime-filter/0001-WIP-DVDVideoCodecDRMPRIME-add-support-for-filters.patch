diff --git a/addons/skin.estuary/xml/Variables.xml b/addons/skin.estuary/xml/Variables.xml
index 48d31556df..fb320882e8 100644
--- a/addons/skin.estuary/xml/Variables.xml
+++ b/addons/skin.estuary/xml/Variables.xml
@@ -703,8 +703,10 @@
 	</variable>
 	<variable name="VideoListThumbVar">
 		<value condition="!String.IsEmpty(Container(6).ListItem.Art(landscape))">$INFO[Container(6).ListItem.Art(landscape)]</value>
+		<value condition="!String.IsEmpty(Container(6).ListItem.Art(poster))">$INFO[Container(6).ListItem.Art(poster)]</value>
 		<value condition="!String.IsEmpty(Container(6).ListItem.Art(thumb))">$INFO[Container(6).ListItem.Art(thumb)]</value>
 		<value condition="!String.IsEmpty(Container(50).ListItem.Art(landscape))">$INFO[Container(50).ListItem.Art(landscape)]</value>
+		<value condition="!String.IsEmpty(Container(50).ListItem.Art(poster))">$INFO[Container(50).ListItem.Art(poster)]</value>
 		<value condition="!String.IsEmpty(Container(50).ListItem.Art(thumb))">$INFO[Container(50).ListItem.Art(thumb)]</value>
 		<value>$INFO[ListItem.Art(thumb)]</value>
 	</variable>
diff --git a/xbmc/ContextMenuItem.h b/xbmc/ContextMenuItem.h
index aee6d82e71..6577de3224 100644
--- a/xbmc/ContextMenuItem.h
+++ b/xbmc/ContextMenuItem.h
@@ -8,6 +8,7 @@
 
 #pragma once
 
+#include <cstdint>
 #include <map>
 #include <memory>
 #include <string>
diff --git a/xbmc/FileItem.cpp b/xbmc/FileItem.cpp
index dcc28288e4..a3fa357232 100644
--- a/xbmc/FileItem.cpp
+++ b/xbmc/FileItem.cpp
@@ -2354,89 +2354,6 @@ const std::shared_ptr<PVR::CPVRChannel> CFileItem::GetPVRChannelInfoTag() const
                                         : std::shared_ptr<CPVRChannel>();
 }
 
-std::string CFileItem::FindTrailer() const
-{
-  std::string strFile2;
-  std::string strFile = m_strPath;
-  if (IsStack())
-  {
-    std::string strPath;
-    URIUtils::GetParentPath(m_strPath,strPath);
-    CStackDirectory dir;
-    std::string strPath2;
-    strPath2 = dir.GetStackedTitlePath(strFile);
-    strFile = URIUtils::AddFileToFolder(strPath,URIUtils::GetFileName(strPath2));
-    CFileItem item(dir.GetFirstStackedFile(m_strPath),false);
-    std::string strTBNFile(URIUtils::ReplaceExtension(ART::GetTBNFile(item), "-trailer"));
-    strFile2 = URIUtils::AddFileToFolder(strPath,URIUtils::GetFileName(strTBNFile));
-  }
-  if (URIUtils::IsInRAR(strFile) || URIUtils::IsInZIP(strFile))
-  {
-    std::string strPath = URIUtils::GetDirectory(strFile);
-    std::string strParent;
-    URIUtils::GetParentPath(strPath,strParent);
-    strFile = URIUtils::AddFileToFolder(strParent,URIUtils::GetFileName(m_strPath));
-  }
-
-  // no local trailer available for these
-  if (NETWORK::IsInternetStream(*this) || URIUtils::IsUPnP(strFile) ||
-      URIUtils::IsBluray(strFile) || IsLiveTV() || IsPlugin() || IsDVD())
-    return "";
-
-  std::string strDir = URIUtils::GetDirectory(strFile);
-  CFileItemList items;
-  CDirectory::GetDirectory(strDir, items, CServiceBroker::GetFileExtensionProvider().GetVideoExtensions(), DIR_FLAG_READ_CACHE | DIR_FLAG_NO_FILE_INFO | DIR_FLAG_NO_FILE_DIRS);
-  URIUtils::RemoveExtension(strFile);
-  strFile += "-trailer";
-  std::string strFile3 = URIUtils::AddFileToFolder(strDir, "movie-trailer");
-
-  // Precompile our REs
-  VECCREGEXP matchRegExps;
-  CRegExp tmpRegExp(true, CRegExp::autoUtf8);
-  const std::vector<std::string>& strMatchRegExps = CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_trailerMatchRegExps;
-
-  std::vector<std::string>::const_iterator strRegExp = strMatchRegExps.begin();
-  while (strRegExp != strMatchRegExps.end())
-  {
-    if (tmpRegExp.RegComp(*strRegExp))
-    {
-      matchRegExps.push_back(tmpRegExp);
-    }
-    ++strRegExp;
-  }
-
-  std::string strTrailer;
-  for (int i = 0; i < items.Size(); i++)
-  {
-    std::string strCandidate = items[i]->m_strPath;
-    URIUtils::RemoveExtension(strCandidate);
-    if (StringUtils::EqualsNoCase(strCandidate, strFile) ||
-        StringUtils::EqualsNoCase(strCandidate, strFile2) ||
-        StringUtils::EqualsNoCase(strCandidate, strFile3))
-    {
-      strTrailer = items[i]->m_strPath;
-      break;
-    }
-    else
-    {
-      VECCREGEXP::iterator expr = matchRegExps.begin();
-
-      while (expr != matchRegExps.end())
-      {
-        if (expr->RegFind(strCandidate) != -1)
-        {
-          strTrailer = items[i]->m_strPath;
-          i = items.Size();
-          break;
-        }
-        ++expr;
-      }
-    }
-  }
-
-  return strTrailer;
-}
-
 VideoDbContentType CFileItem::GetVideoContentType() const
 {
   VideoDbContentType type = VideoDbContentType::MOVIES;
diff --git a/xbmc/FileItem.h b/xbmc/FileItem.h
index 635c964d8d..ffdac95d49 100644
--- a/xbmc/FileItem.h
+++ b/xbmc/FileItem.h
@@ -448,9 +448,6 @@ public:
    */
   std::string GetLocalMetadataPath() const;
 
-  // finds a matching local trailer file
-  std::string FindTrailer() const;
-
   bool LoadMusicTag();
   bool LoadGameTag();
 
diff --git a/xbmc/addons/AddonManager.h b/xbmc/addons/AddonManager.h
index fd7ee70f66..0679ffd81f 100644
--- a/xbmc/addons/AddonManager.h
+++ b/xbmc/addons/AddonManager.h
@@ -11,6 +11,7 @@
 #include "threads/CriticalSection.h"
 #include "utils/EventStream.h"
 
+#include <cstdint>
 #include <map>
 #include <memory>
 #include <mutex>
diff --git a/xbmc/addons/IAddon.h b/xbmc/addons/IAddon.h
index 0bc383055f..d242f60f0e 100644
--- a/xbmc/addons/IAddon.h
+++ b/xbmc/addons/IAddon.h
@@ -8,6 +8,7 @@
 
 #pragma once
 
+#include <cstdint>
 #include <map>
 #include <memory>
 #include <string>
diff --git a/xbmc/cores/RetroPlayer/streams/RetroPlayerVideo.h b/xbmc/cores/RetroPlayer/streams/RetroPlayerVideo.h
index 8d153ab5c2..132b71218c 100644
--- a/xbmc/cores/RetroPlayer/streams/RetroPlayerVideo.h
+++ b/xbmc/cores/RetroPlayer/streams/RetroPlayerVideo.h
@@ -11,6 +11,8 @@
 #include "IRetroPlayerStream.h"
 #include "cores/RetroPlayer/RetroPlayerTypes.h"
 
+#include <cstdint>
+
 extern "C"
 {
 #include <libavutil/pixfmt.h>
diff --git a/xbmc/cores/VideoPlayer/Buffers/VideoBufferDRMPRIME.h b/xbmc/cores/VideoPlayer/Buffers/VideoBufferDRMPRIME.h
index b83ee8ca68..495c428909 100644
--- a/xbmc/cores/VideoPlayer/Buffers/VideoBufferDRMPRIME.h
+++ b/xbmc/cores/VideoPlayer/Buffers/VideoBufferDRMPRIME.h
@@ -54,6 +54,8 @@ public:
   virtual const VideoPicture& GetPicture() const { return m_picture; }
   virtual uint32_t GetWidth() const { return GetPicture().iWidth; }
   virtual uint32_t GetHeight() const { return GetPicture().iHeight; }
+  virtual uint32_t GetXOffset() const { return GetPicture().iXOffset; }
+  virtual uint32_t GetYOffset() const { return GetPicture().iYOffset; }
 
   virtual AVDRMFrameDescriptor* GetDescriptor() const = 0;
   virtual bool IsValid() const { return true; }
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.cpp
index 495d6a25f5..048cdcd18b 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.cpp
@@ -58,6 +58,8 @@ void VideoPicture::Reset()
 
   iWidth = 0;
   iHeight = 0;
+  iXOffset = 0;
+  iYOffset = 0;
   iDisplayWidth = 0;
   iDisplayHeight = 0;
 }
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h
index ca83b1a04f..af31c619b9 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -75,6 +75,8 @@ public:
 
   unsigned int iWidth;
   unsigned int iHeight;
+  size_t iXOffset;
+  size_t iYOffset;
   unsigned int iDisplayWidth;           //< width of the picture without black bars
   unsigned int iDisplayHeight;          //< height of the picture without black bars
 
diff --git a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
index eb2943bb8c..75ec720346 100644
--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp
@@ -506,6 +506,19 @@ void CDVDVideoCodecDRMPRIME::SetPictureParams(VideoPicture* pVideoPicture)
   pVideoPicture->iWidth = m_pFrame->width;
   pVideoPicture->iHeight = m_pFrame->height;
 
+  /* according to ffmpeg devs crop fields in AVFrame are not always maintained actively
+   * and may cause under-shot buffers or mis-aligned strides if not implemented correctly
+   * in decoders. drm_prime frames on the other hand has their own memory allocators,
+   * and as long as the plane number is single, there should be no future regression
+   * related to usage of crop fields.
+   */
+  AVDRMFrameDescriptor* desc = reinterpret_cast<AVDRMFrameDescriptor*>(m_pFrame->data[0]);
+  if (m_pFrame->format == AV_PIX_FMT_DRM_PRIME && desc->nb_layers == 1)
+  {
+    pVideoPicture->iXOffset = m_pFrame->crop_left;
+    pVideoPicture->iYOffset = m_pFrame->crop_top;
+  }
+
   double aspect_ratio = 0;
   AVRational pixel_aspect = m_pFrame->sample_aspect_ratio;
   if (pixel_aspect.num)
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
index 66df0e49c7..2ef7f4d521 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/RendererDRMPRIME.cpp
@@ -77,7 +77,7 @@ CBaseRenderer* CRendererDRMPRIME::Create(CVideoBuffer* buffer)
     if (!plane)
       return nullptr;
 
-    if (!plane->SupportsFormatAndModifier(format, modifier))
+    if (!drm->FindVideoPlane(format, modifier))
       return nullptr;
 
     return new CRendererDRMPRIME();
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/VideoLayerBridgeDRMPRIME.cpp b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/VideoLayerBridgeDRMPRIME.cpp
index 34d1ab6235..44574caa7c 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/VideoLayerBridgeDRMPRIME.cpp
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/HwDecRender/VideoLayerBridgeDRMPRIME.cpp
@@ -118,16 +118,26 @@ bool CVideoLayerBridgeDRMPRIME::Map(CVideoBufferDRMPRIME* buffer)
     flags = DRM_MODE_FB_MODIFIERS;
 
   // add the video frame FB
-  ret = drmModeAddFB2WithModifiers(m_DRM->GetFileDescriptor(), buffer->GetWidth(),
-                                   buffer->GetHeight(), layer->format, handles, pitches, offsets,
-                                   modifier, &buffer->m_fb_id, flags);
+  ret = drmModeAddFB2WithModifiers(m_DRM->GetFileDescriptor(),
+                                   buffer->GetWidth() + buffer->GetXOffset(),
+                                   buffer->GetHeight() + buffer->GetYOffset(), layer->format,
+                                   handles, pitches, offsets, modifier, &buffer->m_fb_id, flags);
   if (ret < 0)
   {
-    CLog::Log(LOGERROR, "CVideoLayerBridgeDRMPRIME::{} - failed to add fb {}, ret = {}",
-              __FUNCTION__, buffer->m_fb_id, ret);
+    CLog::Log(LOGERROR,
+              "CVideoLayerBridgeDRMPRIME::{} - failed to add fb {}, ret = {}, Width: {}, XOffset: "
+              "{}, Height {}, YOffset {}",
+              __FUNCTION__, buffer->m_fb_id, ret, buffer->GetWidth(), buffer->GetXOffset(),
+              buffer->GetHeight(), buffer->GetYOffset());
     return false;
   }
 
+  CLog::Log(LOGERROR,
+            "CVideoLayerBridgeDRMPRIME::{} - successfully added fb {}, ret = {}, Width: {}, "
+            "XOffset: {}, Height {}, YOffset {}",
+            __FUNCTION__, buffer->m_fb_id, ret, buffer->GetWidth(), buffer->GetXOffset(),
+            buffer->GetHeight(), buffer->GetYOffset());
+
   Acquire(buffer);
   return true;
 }
@@ -188,8 +198,8 @@ void CVideoLayerBridgeDRMPRIME::SetVideoPlane(CVideoBufferDRMPRIME* buffer, cons
   auto plane = m_DRM->GetVideoPlane();
   m_DRM->AddProperty(plane, "FB_ID", buffer->m_fb_id);
   m_DRM->AddProperty(plane, "CRTC_ID", m_DRM->GetCrtc()->GetCrtcId());
-  m_DRM->AddProperty(plane, "SRC_X", 0);
-  m_DRM->AddProperty(plane, "SRC_Y", 0);
+  m_DRM->AddProperty(plane, "SRC_X", buffer->GetXOffset() << 16);
+  m_DRM->AddProperty(plane, "SRC_Y", buffer->GetYOffset() << 16);
   m_DRM->AddProperty(plane, "SRC_W", buffer->GetWidth() << 16);
   m_DRM->AddProperty(plane, "SRC_H", buffer->GetHeight() << 16);
   m_DRM->AddProperty(plane, "CRTC_X", static_cast<int32_t>(destRect.x1) & ~1);
diff --git a/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/ConversionMatrix.h b/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/ConversionMatrix.h
index b2c66a7e73..4f43fc0475 100644
--- a/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/ConversionMatrix.h
+++ b/xbmc/cores/VideoPlayer/VideoRenderers/VideoShaders/ConversionMatrix.h
@@ -10,6 +10,7 @@
 
 #include <array>
 #include <cmath>
+#include <cstdint>
 #include <memory>
 
 extern "C" {
diff --git a/xbmc/dialogs/GUIDialogMediaSource.cpp b/xbmc/dialogs/GUIDialogMediaSource.cpp
index 0afbc2d060..1109157c63 100644
--- a/xbmc/dialogs/GUIDialogMediaSource.cpp
+++ b/xbmc/dialogs/GUIDialogMediaSource.cpp
@@ -36,7 +36,7 @@
 #if defined(TARGET_ANDROID)
 #include "utils/FileUtils.h"
 
-#include "platform/android/activity/XBMCApp.h"
+#include "platform/android/storage/AndroidStorageProvider.h"
 #endif
 
 #ifdef TARGET_WINDOWS_STORE
@@ -249,7 +249,8 @@ void CGUIDialogMediaSource::OnPathBrowse(int item)
 #if defined(TARGET_ANDROID)
     // add the default android music directory
     std::string path;
-    if (CXBMCApp::GetExternalStorage(path, "music") && !path.empty() && CDirectory::Exists(path))
+    if (CAndroidStorageProvider::GetExternalStorage(path, "music") && !path.empty() &&
+        CDirectory::Exists(path))
     {
       share1.strPath = path;
       share1.strName = g_localizeStrings.Get(20240);
@@ -303,7 +304,8 @@ void CGUIDialogMediaSource::OnPathBrowse(int item)
 #if defined(TARGET_ANDROID)
     // add the default android video directory
     std::string path;
-    if (CXBMCApp::GetExternalStorage(path, "videos") && !path.empty() && CFileUtils::Exists(path))
+    if (CAndroidStorageProvider::GetExternalStorage(path, "videos") && !path.empty() &&
+        CFileUtils::Exists(path))
     {
       share1.strPath = path;
       share1.strName = g_localizeStrings.Get(20241);
@@ -349,7 +351,8 @@ void CGUIDialogMediaSource::OnPathBrowse(int item)
 #if defined(TARGET_ANDROID)
     // add the default android music directory
     std::string path;
-    if (CXBMCApp::GetExternalStorage(path, "pictures") && !path.empty() && CFileUtils::Exists(path))
+    if (CAndroidStorageProvider::GetExternalStorage(path, "pictures") && !path.empty() &&
+        CFileUtils::Exists(path))
     {
       share1.strPath = path;
       share1.strName = g_localizeStrings.Get(20242);
@@ -358,7 +361,8 @@ void CGUIDialogMediaSource::OnPathBrowse(int item)
     }
 
     path.clear();
-    if (CXBMCApp::GetExternalStorage(path, "photos") && !path.empty() && CFileUtils::Exists(path))
+    if (CAndroidStorageProvider::GetExternalStorage(path, "photos") && !path.empty() &&
+        CFileUtils::Exists(path))
     {
       share1.strPath = path;
       share1.strName = g_localizeStrings.Get(20243);
diff --git a/xbmc/filesystem/DirectoryFactory.cpp b/xbmc/filesystem/DirectoryFactory.cpp
index 465816c4b9..e9c76cba97 100644
--- a/xbmc/filesystem/DirectoryFactory.cpp
+++ b/xbmc/filesystem/DirectoryFactory.cpp
@@ -97,7 +97,14 @@ using namespace XFILE;
  */
 IDirectory* CDirectoryFactory::Create(const CFileItem& item)
 {
-  return Create(CURL{item.GetDynPath()});
+  CURL curl{item.GetDynPath()};
+
+  // Store the mimetype, allowing the PlayListFactory to set it on the created FileItem
+  const std::string& mimeType = item.GetMimeType();
+  if (!mimeType.empty())
+    curl.SetOption("mimetype", mimeType);
+
+  return Create(curl);
 }
 
 /*!
diff --git a/xbmc/filesystem/PlaylistFileDirectory.cpp b/xbmc/filesystem/PlaylistFileDirectory.cpp
index d95989067f..18e5d7affa 100644
--- a/xbmc/filesystem/PlaylistFileDirectory.cpp
+++ b/xbmc/filesystem/PlaylistFileDirectory.cpp
@@ -25,12 +25,11 @@ namespace XFILE
 
   bool CPlaylistFileDirectory::GetDirectory(const CURL& url, CFileItemList& items)
   {
-    const std::string pathToUrl = url.Get();
-    std::unique_ptr<PLAYLIST::CPlayList> pPlayList(PLAYLIST::CPlayListFactory::Create(pathToUrl));
+    std::unique_ptr<PLAYLIST::CPlayList> pPlayList(PLAYLIST::CPlayListFactory::Create(url));
     if (nullptr != pPlayList)
     {
       // load it
-      if (!pPlayList->Load(pathToUrl))
+      if (!pPlayList->Load(url.Get()))
         return false; //hmmm unable to load playlist?
 
       PLAYLIST::CPlayList playlist = *pPlayList;
@@ -47,12 +46,11 @@ namespace XFILE
 
   bool CPlaylistFileDirectory::ContainsFiles(const CURL& url)
   {
-    const std::string pathToUrl = url.Get();
-    std::unique_ptr<PLAYLIST::CPlayList> pPlayList(PLAYLIST::CPlayListFactory::Create(pathToUrl));
+    std::unique_ptr<PLAYLIST::CPlayList> pPlayList(PLAYLIST::CPlayListFactory::Create(url));
     if (nullptr != pPlayList)
     {
       // load it
-      if (!pPlayList->Load(pathToUrl))
+      if (!pPlayList->Load(url.Get()))
         return false; //hmmm unable to load playlist?
 
       return (pPlayList->size() > 1);
diff --git a/xbmc/guilib/FFmpegImage.h b/xbmc/guilib/FFmpegImage.h
index 0f7cee380c..8d34def513 100644
--- a/xbmc/guilib/FFmpegImage.h
+++ b/xbmc/guilib/FFmpegImage.h
@@ -9,6 +9,8 @@
 #pragma once
 
 #include "iimage.h"
+
+#include <cstdint>
 #include <memory>
 
 extern "C"
diff --git a/xbmc/input/keymaps/remote/IRTranslator.h b/xbmc/input/keymaps/remote/IRTranslator.h
index 96eddcf153..862fb7599c 100644
--- a/xbmc/input/keymaps/remote/IRTranslator.h
+++ b/xbmc/input/keymaps/remote/IRTranslator.h
@@ -8,6 +8,7 @@
 
 #pragma once
 
+#include <cstdint>
 #include <map>
 #include <memory>
 #include <string>
diff --git a/xbmc/messaging/ThreadMessage.h b/xbmc/messaging/ThreadMessage.h
index 1a277ffcd4..8360d30cc1 100644
--- a/xbmc/messaging/ThreadMessage.h
+++ b/xbmc/messaging/ThreadMessage.h
@@ -8,6 +8,7 @@
 
 #pragma once
 
+#include <cstdint>
 #include <memory>
 #include <string>
 #include <utility>
diff --git a/xbmc/platform/android/PlatformAndroid.cpp b/xbmc/platform/android/PlatformAndroid.cpp
index ba9208f6f5..d35896cd14 100644
--- a/xbmc/platform/android/PlatformAndroid.cpp
+++ b/xbmc/platform/android/PlatformAndroid.cpp
@@ -17,6 +17,7 @@
 
 #include "platform/android/activity/XBMCApp.h"
 #include "platform/android/powermanagement/AndroidPowerSyscall.h"
+#include "platform/android/storage/AndroidStorageProvider.h"
 
 #include <stdlib.h>
 
@@ -66,7 +67,7 @@ void CPlatformAndroid::PlatformSyslog()
       CJNIBuild::BRAND, CJNIBuild::MODEL, CJNIBuild::HARDWARE);
 
   std::string extstorage;
-  bool extready = CXBMCApp::GetExternalStorage(extstorage);
+  const bool extready = CAndroidStorageProvider::GetExternalStorage(extstorage);
   CLog::Log(
       LOGINFO, "External storage path = {}; status = {}; Permissions = {}{}", extstorage,
       extready ? "ok" : "nok",
diff --git a/xbmc/platform/android/activity/XBMCApp.cpp b/xbmc/platform/android/activity/XBMCApp.cpp
index b4cdde669c..10e00d0146 100644
--- a/xbmc/platform/android/activity/XBMCApp.cpp
+++ b/xbmc/platform/android/activity/XBMCApp.cpp
@@ -81,7 +81,6 @@
 #include <androidjni/Cursor.h>
 #include <androidjni/Display.h>
 #include <androidjni/DisplayManager.h>
-#include <androidjni/Environment.h>
 #include <androidjni/File.h>
 #include <androidjni/Intent.h>
 #include <androidjni/IntentFilter.h>
@@ -1091,42 +1090,6 @@ int CXBMCApp::GetBatteryLevel() const
   return m_batteryLevel;
 }
 
-bool CXBMCApp::GetExternalStorage(std::string &path, const std::string &type /* = "" */)
-{
-  std::string sType;
-  std::string mountedState;
-  bool mounted = false;
-
-  if(type == "files" || type.empty())
-  {
-    CJNIFile external = CJNIEnvironment::getExternalStorageDirectory();
-    if (external)
-      path = external.getAbsolutePath();
-  }
-  else
-  {
-    if (type == "music")
-      sType = "Music"; // Environment.DIRECTORY_MUSIC
-    else if (type == "videos")
-      sType = "Movies"; // Environment.DIRECTORY_MOVIES
-    else if (type == "pictures")
-      sType = "Pictures"; // Environment.DIRECTORY_PICTURES
-    else if (type == "photos")
-      sType = "DCIM"; // Environment.DIRECTORY_DCIM
-    else if (type == "downloads")
-      sType = "Download"; // Environment.DIRECTORY_DOWNLOADS
-    if (!sType.empty())
-    {
-      CJNIFile external = CJNIEnvironment::getExternalStoragePublicDirectory(sType);
-      if (external)
-        path = external.getAbsolutePath();
-    }
-  }
-  mountedState = CJNIEnvironment::getExternalStorageState();
-  mounted = (mountedState == "mounted" || mountedState == "mounted_ro");
-  return mounted && !path.empty();
-}
-
 // Used in Application.cpp to figure out volume steps
 int CXBMCApp::GetMaxSystemVolume()
 {
diff --git a/xbmc/platform/android/activity/XBMCApp.h b/xbmc/platform/android/activity/XBMCApp.h
index 6fa89cbce3..73f5dcdf09 100644
--- a/xbmc/platform/android/activity/XBMCApp.h
+++ b/xbmc/platform/android/activity/XBMCApp.h
@@ -166,13 +166,6 @@ public:
                             const std::string& className = std::string());
   std::vector<androidPackage> GetApplications() const;
 
-  /*!
-   * \brief If external storage is available, it returns the path for the external storage (for the specified type)
-   * \param path will contain the path of the external storage (for the specified type)
-   * \param type optional type. Possible values are "", "files", "music", "videos", "pictures", "photos, "downloads"
-   * \return true if external storage is available and a valid path has been stored in the path parameter
-   */
-  static bool GetExternalStorage(std::string& path, const std::string& type = "");
   static int GetMaxSystemVolume();
   static float GetSystemVolume();
   static void SetSystemVolume(float percent);
diff --git a/xbmc/platform/android/storage/AndroidStorageProvider.cpp b/xbmc/platform/android/storage/AndroidStorageProvider.cpp
index 33f7ab8a23..59fe3d6ae2 100644
--- a/xbmc/platform/android/storage/AndroidStorageProvider.cpp
+++ b/xbmc/platform/android/storage/AndroidStorageProvider.cpp
@@ -17,8 +17,6 @@
 #include "utils/URIUtils.h"
 #include "utils/log.h"
 
-#include "platform/android/activity/XBMCApp.h"
-
 #include <array>
 #include <cstdio>
 #include <cstdlib>
@@ -131,7 +129,7 @@ void CAndroidStorageProvider::GetLocalDrives(VECSOURCES &localDrives)
 
   // external directory
   std::string path;
-  if (CXBMCApp::GetExternalStorage(path) && !path.empty()  && XFILE::CDirectory::Exists(path))
+  if (GetExternalStorage(path) && !path.empty() && XFILE::CDirectory::Exists(path))
   {
     share.strPath = path;
     share.strName = g_localizeStrings.Get(21456);
@@ -391,8 +389,7 @@ std::vector<std::string> CAndroidStorageProvider::GetDiskUsage()
   usage.clear();
   // add external storage if available
   std::string path;
-  if (CXBMCApp::GetExternalStorage(path) && !path.empty() && GetStorageUsage(path, usage) &&
-      !usage.empty())
+  if (GetExternalStorage(path) && !path.empty() && GetStorageUsage(path, usage) && !usage.empty())
     result.push_back(usage);
 
   // add removable storage
@@ -451,3 +448,41 @@ bool CAndroidStorageProvider::GetStorageUsage(const std::string& path, std::stri
       PATH_MAXLEN, totalSize, "G", usedSize, "G", freeSize, "G", usedPercentage, "%");
   return true;
 }
+
+bool CAndroidStorageProvider::GetExternalStorage(std::string& path,
+                                                 const std::string& type /* = "" */)
+{
+  std::string sType;
+  std::string mountedState;
+  bool mounted = false;
+
+  if (type == "files" || type.empty())
+  {
+    CJNIFile external = CJNIEnvironment::getExternalStorageDirectory();
+    if (external)
+      path = external.getAbsolutePath();
+  }
+  else
+  {
+    if (type == "music")
+      sType = "Music"; // Environment.DIRECTORY_MUSIC
+    else if (type == "videos")
+      sType = "Movies"; // Environment.DIRECTORY_MOVIES
+    else if (type == "pictures")
+      sType = "Pictures"; // Environment.DIRECTORY_PICTURES
+    else if (type == "photos")
+      sType = "DCIM"; // Environment.DIRECTORY_DCIM
+    else if (type == "downloads")
+      sType = "Download"; // Environment.DIRECTORY_DOWNLOADS
+    if (!sType.empty())
+    {
+      CJNIFile external = CJNIEnvironment::getExternalStoragePublicDirectory(sType);
+      if (external)
+        path = external.getAbsolutePath();
+    }
+  }
+
+  mountedState = CJNIEnvironment::getExternalStorageState();
+  mounted = (mountedState == "mounted" || mountedState == "mounted_ro");
+  return mounted && !path.empty();
+}
diff --git a/xbmc/platform/android/storage/AndroidStorageProvider.h b/xbmc/platform/android/storage/AndroidStorageProvider.h
index e39ff60dea..abd7b8e3b2 100644
--- a/xbmc/platform/android/storage/AndroidStorageProvider.h
+++ b/xbmc/platform/android/storage/AndroidStorageProvider.h
@@ -30,6 +30,14 @@ public:
 
   bool PumpDriveChangeEvents(IStorageEventsCallback* callback) override;
 
+  /*!
+   * \brief If external storage is available, it returns the path for the external storage (for the specified type)
+   * \param path will contain the path of the external storage (for the specified type)
+   * \param type optional type. Possible values are "", "files", "music", "videos", "pictures", "photos, "downloads"
+   * \return true if external storage is available and a valid path has been stored in the path parameter
+   */
+  static bool GetExternalStorage(std::string& path, const std::string& type = "");
+
 private:
   std::string unescape(const std::string& str);
   VECSOURCES m_removableDrives;
diff --git a/xbmc/playlists/PlayListFactory.cpp b/xbmc/playlists/PlayListFactory.cpp
index 7fe5ff6fcb..63b9bd401d 100644
--- a/xbmc/playlists/PlayListFactory.cpp
+++ b/xbmc/playlists/PlayListFactory.cpp
@@ -9,6 +9,7 @@
 #include "PlayListFactory.h"
 
 #include "FileItem.h"
+#include "URL.h"
 #include "network/NetworkFileItemClassify.h"
 #include "playlists/PlayListASX.h"
 #include "playlists/PlayListB4S.h"
@@ -25,6 +26,19 @@
 namespace KODI::PLAYLIST
 {
 
+CPlayList* CPlayListFactory::Create(const CURL& url)
+{
+  CFileItem item{url.Get(), false};
+
+  if (url.HasOption("mimetype"))
+  {
+    item.SetContentLookup(false);
+    item.SetMimeType(url.GetOption("mimetype"));
+  }
+
+  return Create(item);
+}
+
 CPlayList* CPlayListFactory::Create(const std::string& filename)
 {
   CFileItem item(filename,false);
diff --git a/xbmc/playlists/PlayListFactory.h b/xbmc/playlists/PlayListFactory.h
index 5161150ea5..410c1e392d 100644
--- a/xbmc/playlists/PlayListFactory.h
+++ b/xbmc/playlists/PlayListFactory.h
@@ -20,6 +20,7 @@ namespace KODI::PLAYLIST
   class CPlayListFactory
   {
   public:
+    static CPlayList* Create(const CURL& url);
     static CPlayList* Create(const std::string& filename);
     static CPlayList* Create(const CFileItem& item);
     static bool IsPlaylist(const CURL& url);
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index 0f4c5a7871..051636cb05 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -13,6 +13,7 @@
 #include "settings/lib/ISettingsHandler.h"
 #include "utils/SortUtils.h"
 
+#include <cstdint>
 #include <set>
 #include <string>
 #include <utility>
diff --git a/xbmc/utils/Archive.h b/xbmc/utils/Archive.h
index a1af0c3cf8..341c07d779 100644
--- a/xbmc/utils/Archive.h
+++ b/xbmc/utils/Archive.h
@@ -8,6 +8,7 @@
 
 #pragma once
 
+#include <cstdint>
 #include <cstring>
 #include <memory>
 #include <string>
diff --git a/xbmc/video/VideoInfoScanner.cpp b/xbmc/video/VideoInfoScanner.cpp
index c02ee60282..10cc30a6c9 100644
--- a/xbmc/video/VideoInfoScanner.cpp
+++ b/xbmc/video/VideoInfoScanner.cpp
@@ -49,6 +49,7 @@
 #include "video/VideoFileItemClassify.h"
 #include "video/VideoManagerTypes.h"
 #include "video/VideoThumbLoader.h"
+#include "video/VideoUtils.h"
 #include "video/dialogs/GUIDialogVideoManagerExtras.h"
 #include "video/dialogs/GUIDialogVideoManagerVersions.h"
 
@@ -59,7 +60,7 @@
 using namespace XFILE;
 using namespace ADDON;
 using namespace KODI::MESSAGING;
-using namespace KODI::VIDEO;
+using namespace KODI;
 
 using KODI::MESSAGING::HELPERS::DialogResponse;
 using KODI::UTILITY::CDigest;
@@ -1527,7 +1528,7 @@ namespace KODI::VIDEO
     if (content == CONTENT_MOVIES)
     {
       // find local trailer first
-      std::string strTrailer = pItem->FindTrailer();
+      std::string strTrailer = UTILS::FindTrailer(*pItem);
       if (!strTrailer.empty())
         movieDetails.m_strTrailer = strTrailer;
 
diff --git a/xbmc/video/VideoUtils.cpp b/xbmc/video/VideoUtils.cpp
index 16f6c0cd38..73f38e4ead 100644
--- a/xbmc/video/VideoUtils.cpp
+++ b/xbmc/video/VideoUtils.cpp
@@ -13,13 +13,18 @@
 #include "ServiceBroker.h"
 #include "Util.h"
 #include "filesystem/Directory.h"
+#include "filesystem/StackDirectory.h"
 #include "filesystem/VideoDatabaseDirectory/QueryParams.h"
+#include "network/NetworkFileItemClassify.h"
 #include "playlists/PlayListFileItemClassify.h"
 #include "pvr/filesystem/PVRGUIDirectory.h"
+#include "settings/AdvancedSettings.h"
 #include "settings/SettingUtils.h"
 #include "settings/Settings.h"
 #include "settings/SettingsComponent.h"
 #include "settings/lib/Setting.h"
+#include "utils/ArtUtils.h"
+#include "utils/FileExtensionProvider.h"
 #include "utils/FileUtils.h"
 #include "utils/URIUtils.h"
 #include "utils/log.h"
@@ -187,6 +192,86 @@ KODI::VIDEO::UTILS::ResumeInformation GetNonFolderItemResumeInformation(const CF
 
 namespace KODI::VIDEO::UTILS
 {
+
+std::string FindTrailer(const CFileItem& item)
+{
+  std::string strFile2;
+  std::string strFile = item.GetPath();
+  if (item.IsStack())
+  {
+    std::string strPath;
+    URIUtils::GetParentPath(item.GetPath(), strPath);
+    XFILE::CStackDirectory dir;
+    std::string strPath2;
+    strPath2 = dir.GetStackedTitlePath(strFile);
+    strFile = URIUtils::AddFileToFolder(strPath, URIUtils::GetFileName(strPath2));
+    CFileItem sitem(dir.GetFirstStackedFile(item.GetPath()), false);
+    std::string strTBNFile(URIUtils::ReplaceExtension(ART::GetTBNFile(sitem), "-trailer"));
+    strFile2 = URIUtils::AddFileToFolder(strPath, URIUtils::GetFileName(strTBNFile));
+  }
+  if (URIUtils::IsInRAR(strFile) || URIUtils::IsInZIP(strFile))
+  {
+    std::string strPath = URIUtils::GetDirectory(strFile);
+    std::string strParent;
+    URIUtils::GetParentPath(strPath, strParent);
+    strFile = URIUtils::AddFileToFolder(strParent, URIUtils::GetFileName(item.GetPath()));
+  }
+
+  // no local trailer available for these
+  if (NETWORK::IsInternetStream(item) || URIUtils::IsUPnP(strFile) || URIUtils::IsBluray(strFile) ||
+      item.IsLiveTV() || item.IsPlugin() || item.IsDVD())
+    return "";
+
+  std::string strDir = URIUtils::GetDirectory(strFile);
+  CFileItemList items;
+  XFILE::CDirectory::GetDirectory(
+      strDir, items, CServiceBroker::GetFileExtensionProvider().GetVideoExtensions(),
+      XFILE::DIR_FLAG_READ_CACHE | XFILE::DIR_FLAG_NO_FILE_INFO | XFILE::DIR_FLAG_NO_FILE_DIRS);
+  URIUtils::RemoveExtension(strFile);
+  strFile += "-trailer";
+  std::string strFile3 = URIUtils::AddFileToFolder(strDir, "movie-trailer");
+
+  // Precompile our REs
+  VECCREGEXP matchRegExps;
+  CRegExp tmpRegExp(true, CRegExp::autoUtf8);
+  const std::vector<std::string>& strMatchRegExps =
+      CServiceBroker::GetSettingsComponent()->GetAdvancedSettings()->m_trailerMatchRegExps;
+
+  for (const auto& strRegExp : strMatchRegExps)
+  {
+    if (tmpRegExp.RegComp(strRegExp))
+      matchRegExps.push_back(tmpRegExp);
+  }
+
+  std::string strTrailer;
+  for (int i = 0; i < items.Size(); i++)
+  {
+    std::string strCandidate = items[i]->GetPath();
+    URIUtils::RemoveExtension(strCandidate);
+    if (StringUtils::EqualsNoCase(strCandidate, strFile) ||
+        StringUtils::EqualsNoCase(strCandidate, strFile2) ||
+        StringUtils::EqualsNoCase(strCandidate, strFile3))
+    {
+      strTrailer = items[i]->GetPath();
+      break;
+    }
+    else
+    {
+      for (auto& expr : matchRegExps)
+      {
+        if (expr.RegFind(strCandidate) != -1)
+        {
+          strTrailer = items[i]->GetPath();
+          i = items.Size();
+          break;
+        }
+      }
+    }
+  }
+
+  return strTrailer;
+}
+
 std::string GetOpticalMediaPath(const CFileItem& item)
 {
   auto exists = [&item](const std::string& file)
diff --git a/xbmc/video/VideoUtils.h b/xbmc/video/VideoUtils.h
index c344072ffe..2ee611c4e8 100644
--- a/xbmc/video/VideoUtils.h
+++ b/xbmc/video/VideoUtils.h
@@ -14,6 +14,13 @@ class CFileItem;
 
 namespace KODI::VIDEO::UTILS
 {
+
+/*! \brief
+ *  Find a local trailer file for a given file item
+ *  \return non-empty string with path of trailer if found
+ */
+std::string FindTrailer(const CFileItem& item);
+
 /*!
  \brief Check whether an item is an optical media folder or its parent.
   This will return the non-empty path to the playable entry point of the media
diff --git a/xbmc/video/dialogs/GUIDialogVideoInfo.cpp b/xbmc/video/dialogs/GUIDialogVideoInfo.cpp
index 7d93996ba5..f7c931e4b0 100644
--- a/xbmc/video/dialogs/GUIDialogVideoInfo.cpp
+++ b/xbmc/video/dialogs/GUIDialogVideoInfo.cpp
@@ -59,6 +59,7 @@
 #include "video/VideoItemArtworkHandler.h"
 #include "video/VideoLibraryQueue.h"
 #include "video/VideoThumbLoader.h"
+#include "video/VideoUtils.h"
 #include "video/dialogs/GUIDialogVideoManagerExtras.h"
 #include "video/dialogs/GUIDialogVideoManagerVersions.h"
 #include "video/guilib/VideoGUIUtils.h"
@@ -453,7 +454,7 @@ void CGUIDialogVideoInfo::SetMovie(const CFileItem *item)
     if (m_movieItem->GetVideoInfoTag()->m_strTrailer.empty() ||
         URIUtils::IsInternetStream(m_movieItem->GetVideoInfoTag()->m_strTrailer))
     {
-      std::string localTrailer = m_movieItem->FindTrailer();
+      std::string localTrailer = VIDEO::UTILS::FindTrailer(*m_movieItem);
       if (!localTrailer.empty())
       {
         m_movieItem->GetVideoInfoTag()->m_strTrailer = localTrailer;
diff --git a/xbmc/video/test/TestVideoUtils.cpp b/xbmc/video/test/TestVideoUtils.cpp
index 579fff0180..9feb832e5b 100644
--- a/xbmc/video/test/TestVideoUtils.cpp
+++ b/xbmc/video/test/TestVideoUtils.cpp
@@ -7,6 +7,7 @@
  */
 
 #include "FileItem.h"
+#include "URL.h"
 #include "Util.h"
 #include "filesystem/Directory.h"
 #include "platform/Filesystem.h"
@@ -22,12 +23,23 @@
 using namespace KODI;
 namespace fs = KODI::PLATFORM::FILESYSTEM;
 
+namespace
+{
+
 using OptDef = std::pair<std::string, bool>;
 
 class OpticalMediaPathTest : public testing::WithParamInterface<OptDef>, public testing::Test
 {
 };
 
+using TrailerDef = std::pair<std::string, std::string>;
+
+class TrailerTest : public testing::WithParamInterface<TrailerDef>, public testing::Test
+{
+};
+
+} // namespace
+
 TEST_P(OpticalMediaPathTest, GetOpticalMediaPath)
 {
   std::error_code ec;
@@ -57,3 +69,53 @@ const auto mediapath_tests = std::array{
 };
 
 INSTANTIATE_TEST_SUITE_P(TestVideoUtils, OpticalMediaPathTest, testing::ValuesIn(mediapath_tests));
+
+TEST_P(TrailerTest, FindTrailer)
+{
+  std::string temp_path;
+  if (!GetParam().second.empty())
+  {
+    std::error_code ec;
+    temp_path = fs::create_temp_directory(ec);
+    EXPECT_FALSE(ec);
+    XFILE::CDirectory::Create(temp_path);
+    const std::string file_path = URIUtils::AddFileToFolder(temp_path, GetParam().second);
+    {
+      std::ofstream of(file_path);
+    }
+    URIUtils::AddSlashAtEnd(temp_path);
+  }
+
+  std::string input_path = GetParam().first;
+  if (!temp_path.empty())
+  {
+    StringUtils::Replace(input_path, "#DIRECTORY#", temp_path);
+    StringUtils::Replace(input_path, "#URLENCODED_DIRECTORY#", CURL::Encode(temp_path));
+  }
+
+  CFileItem item(input_path, false);
+  EXPECT_EQ(VIDEO::UTILS::FindTrailer(item),
+            GetParam().second.empty() ? ""
+                                      : URIUtils::AddFileToFolder(temp_path, GetParam().second));
+
+  if (!temp_path.empty())
+    XFILE::CDirectory::RemoveRecursive(temp_path);
+}
+
+const auto trailer_tests = std::array{
+    TrailerDef{"https://some.where/foo", ""},
+    TrailerDef{"upnp://1/2/3", ""},
+    TrailerDef{"bluray://1", ""},
+    TrailerDef{"pvr://foobar.pvr", ""},
+    TrailerDef{"plugin://plugin.video.foo/foo?param=1", ""},
+    TrailerDef{"dvd://1", ""},
+    TrailerDef{"stack://#DIRECTORY#foo-cd1.avi , #DIRECTORY#foo-cd2.avi", "foo-trailer.mkv"},
+    TrailerDef{"stack://#DIRECTORY#foo-cd1.avi , #DIRECTORY#foo-cd2.avi", "foo-cd1-trailer.avi"},
+    TrailerDef{"stack://#DIRECTORY#foo-cd1.avi , #DIRECTORY#foo-cd2.avi", "movie-trailer.mp4"},
+    TrailerDef{"zip://#URLENCODED_DIRECTORY#bar.zip/bar.avi", "bar-trailer.mov"},
+    TrailerDef{"zip://#URLENCODED_DIRECTORY#bar.zip/bar.mkv", "movie-trailer.ogm"},
+    TrailerDef{"#DIRECTORY#bar.mkv", "bar-trailer.mkv"},
+    TrailerDef{"#DIRECTORY#bar.mkv", "movie-trailer.avi"},
+};
+
+INSTANTIATE_TEST_SUITE_P(TestVideoUtils, TrailerTest, testing::ValuesIn(trailer_tests));
diff --git a/xbmc/windowing/gbm/drm/DRMObject.cpp b/xbmc/windowing/gbm/drm/DRMObject.cpp
index 5ffce40fa3..99dda24490 100644
--- a/xbmc/windowing/gbm/drm/DRMObject.cpp
+++ b/xbmc/windowing/gbm/drm/DRMObject.cpp
@@ -105,6 +105,25 @@ std::optional<uint64_t> CDRMObject::GetPropertyValue(std::string_view name,
   return {};
 }
 
+std::optional<std::span<uint64_t, 2>> CDRMObject::GetRangePropertyLimits(std::string_view name)
+{
+  auto property = std::find_if(m_propsInfo.begin(), m_propsInfo.end(),
+                               [&name](const auto& prop) { return prop->name == name; });
+
+  if (property == m_propsInfo.end())
+    return {};
+
+  auto prop = property->get();
+
+  if (!static_cast<bool>(drm_property_type_is(prop, DRM_MODE_PROP_RANGE)))
+    return {};
+
+  if (prop->count_values != 2)
+    return {};
+
+  return std::make_optional<std::span<uint64_t, 2>>(prop->values, 2);
+}
+
 bool CDRMObject::SetProperty(const std::string& name, uint64_t value)
 {
   auto property = std::find_if(m_propsInfo.begin(), m_propsInfo.end(),
@@ -130,3 +149,14 @@ bool CDRMObject::SupportsProperty(const std::string& name)
 
   return false;
 }
+
+std::optional<bool> CDRMObject::IsPropertyImmutable(std::string_view name)
+{
+  auto property = std::find_if(m_propsInfo.begin(), m_propsInfo.end(),
+                               [&name](const auto& prop) { return prop->name == name; });
+
+  if (property == m_propsInfo.end())
+    return {};
+
+  return static_cast<bool>(drm_property_type_is(property->get(), DRM_MODE_PROP_IMMUTABLE));
+}
diff --git a/xbmc/windowing/gbm/drm/DRMObject.h b/xbmc/windowing/gbm/drm/DRMObject.h
index c4200b1a86..39ba28a004 100644
--- a/xbmc/windowing/gbm/drm/DRMObject.h
+++ b/xbmc/windowing/gbm/drm/DRMObject.h
@@ -12,6 +12,7 @@
 #include <cstdint>
 #include <memory>
 #include <optional>
+#include <span>
 #include <string_view>
 #include <vector>
 
@@ -40,6 +41,8 @@ public:
 
   bool SetProperty(const std::string& name, uint64_t value);
   bool SupportsProperty(const std::string& name);
+  std::optional<bool> IsPropertyImmutable(std::string_view name);
+  std::optional<std::span<uint64_t, 2>> GetRangePropertyLimits(std::string_view name);
 
 protected:
   explicit CDRMObject(int fd);
diff --git a/xbmc/windowing/gbm/drm/DRMUtils.cpp b/xbmc/windowing/gbm/drm/DRMUtils.cpp
index 3dd4ee9783..22db758ab6 100644
--- a/xbmc/windowing/gbm/drm/DRMUtils.cpp
+++ b/xbmc/windowing/gbm/drm/DRMUtils.cpp
@@ -181,77 +181,130 @@ bool CDRMUtils::FindPreferredMode()
   return true;
 }
 
-bool CDRMUtils::FindPlanes()
+bool CDRMUtils::FindGuiPlane()
 {
-  for (size_t i = 0; i < m_crtcs.size(); i++)
-  {
-    if (!(m_encoder->GetPossibleCrtcs() & (1 << i)))
+  /* find the gui plane which support ARGB and 8bit or 10 bit XRGB
+     * prefer the one which does not support NV12, because it can be re-used in future for video
+     * prefer the highest id number because they are listed on top where zpos is not available
+     * and use the gui plane crtc as the crtc
+     * */
+  CDRMPlane* gui_plane_nv12{nullptr};
+  CDRMPlane* gui_plane{nullptr};
+  CDRMCrtc* gui_crtc_nv12{nullptr};
+  CDRMCrtc* gui_crtc{nullptr};
+
+  for (size_t crtc_offset = 0; crtc_offset < m_crtcs.size(); crtc_offset++)
+  {
+    if (!(m_encoder->GetPossibleCrtcs() & (1 << crtc_offset)))
       continue;
 
-    auto videoPlane = std::find_if(m_planes.begin(), m_planes.end(), [&i](auto& plane) {
-      if (plane->GetPossibleCrtcs() & (1 << i))
-      {
-        return plane->SupportsFormat(DRM_FORMAT_NV12);
-      }
-      return false;
-    });
-
-    uint32_t videoPlaneId{0};
-
-    if (videoPlane != m_planes.end())
-      videoPlaneId = videoPlane->get()->GetPlaneId();
-
-    auto guiPlane =
-        std::find_if(m_planes.begin(), m_planes.end(), [&i, &videoPlaneId](auto& plane) {
-          if (plane->GetPossibleCrtcs() & (1 << i))
-          {
-            return (plane->GetPlaneId() != videoPlaneId &&
-                    (videoPlaneId == 0 || plane->SupportsFormat(DRM_FORMAT_ARGB8888)) &&
-                    (plane->SupportsFormat(DRM_FORMAT_XRGB2101010) ||
-                     plane->SupportsFormat(DRM_FORMAT_XRGB8888)));
-          }
-          return false;
-        });
-
-    if (videoPlane != m_planes.end() && guiPlane != m_planes.end())
+    for (auto& plane : m_planes)
     {
-      m_crtc = m_crtcs[i].get();
-      m_video_plane = videoPlane->get();
-      m_gui_plane = guiPlane->get();
-      break;
-    }
+      if (!(plane.get()->GetPossibleCrtcs() & (1 << crtc_offset)))
+        continue;
 
-    if (guiPlane != m_planes.end())
-    {
-      if (!m_crtc && m_encoder->GetCrtcId() == m_crtcs[i]->GetCrtcId())
+      if (plane.get()->SupportsFormat(DRM_FORMAT_ARGB8888) &&
+          (plane.get()->SupportsFormat(DRM_FORMAT_XRGB2101010) ||
+           plane.get()->SupportsFormat(DRM_FORMAT_XRGB8888)))
       {
-        m_crtc = m_crtcs[i].get();
-        m_gui_plane = guiPlane->get();
-        m_video_plane = nullptr;
+        if (plane.get()->SupportsFormat(DRM_FORMAT_NV12) &&
+            (gui_plane_nv12 == nullptr || gui_plane_nv12->GetId() < plane.get()->GetId()))
+        {
+          gui_plane_nv12 = plane.get();
+          gui_crtc_nv12 = m_crtcs[crtc_offset].get();
+        }
+        else if (!plane.get()->SupportsFormat(DRM_FORMAT_NV12) &&
+                 (gui_plane == nullptr || gui_plane->GetId() < plane.get()->GetId()))
+        {
+          gui_plane = plane.get();
+          gui_crtc = m_crtcs[crtc_offset].get();
+        }
       }
     }
   }
 
-  CLog::Log(LOGINFO, "CDRMUtils::{} - using crtc: {}", __FUNCTION__, m_crtc->GetCrtcId());
-
-  // video plane may not be available
-  if (m_video_plane)
-    CLog::Log(LOGDEBUG, "CDRMUtils::{} - using video plane {}", __FUNCTION__,
-              m_video_plane->GetPlaneId());
-
-  if (m_gui_plane->SupportsFormat(DRM_FORMAT_XRGB2101010))
+  // fallback to NV12 supporting plane
+  if (gui_plane == nullptr)
   {
-    m_gui_plane->SetFormat(DRM_FORMAT_XRGB2101010);
-    CLog::Log(LOGDEBUG, "CDRMUtils::{} - using 10bit gui plane {}", __FUNCTION__,
-              m_gui_plane->GetPlaneId());
+    gui_crtc = gui_crtc_nv12;
+    gui_plane = gui_plane_nv12;
   }
-  else
+
+  if (gui_plane != nullptr)
   {
-    m_gui_plane->SetFormat(DRM_FORMAT_XRGB8888);
-    CLog::Log(LOGDEBUG, "CDRMUtils::{} - using gui plane {}", __FUNCTION__,
-              m_gui_plane->GetPlaneId());
+    m_crtc = gui_crtc;
+    m_gui_plane = gui_plane;
+
+    CLog::Log(LOGINFO, "CDRMUtils::{} - using crtc: {}", __FUNCTION__, m_crtc->GetCrtcId());
+    if (m_gui_plane->SupportsFormat(DRM_FORMAT_XRGB2101010))
+    {
+      m_gui_plane->SetFormat(DRM_FORMAT_XRGB2101010);
+      CLog::Log(LOGDEBUG, "CDRMUtils::{} - using 10bit gui plane {}", __FUNCTION__,
+                m_gui_plane->GetPlaneId());
+    }
+    else
+    {
+      m_gui_plane->SetFormat(DRM_FORMAT_XRGB8888);
+      CLog::Log(LOGDEBUG, "CDRMUtils::{} - using gui plane {}", __FUNCTION__,
+                m_gui_plane->GetPlaneId());
+    }
+    return true;
   }
 
+  CLog::Log(LOGERROR, "CDRMUtils::{} - Can not find a GUI plane", __FUNCTION__);
+  return false;
+}
+
+bool CDRMUtils::FindVideoPlane(uint32_t format, uint64_t modifier)
+{
+  bool supports_zpos = m_gui_plane->SupportsProperty("zpos");
+  bool zpos_immutable = supports_zpos && m_gui_plane->IsPropertyImmutable("zpos").value();
+
+  auto crtc_offset = std::distance(
+      m_crtcs.begin(),
+      std::find_if(m_crtcs.begin(), m_crtcs.end(),
+                   [this](auto& crtc) { return crtc->GetCrtcId() == m_crtc->GetCrtcId(); }));
+
+  auto guiplane_id = m_gui_plane->GetId();
+  auto videoPlane = std::find_if(m_planes.begin(), m_planes.end(),
+                                 [&crtc_offset, &format, &modifier, &guiplane_id](auto& plane)
+                                 {
+                                   if (plane->GetPossibleCrtcs() & (1 << crtc_offset))
+                                   {
+                                     return (guiplane_id != plane->GetPlaneId() &&
+                                             plane->SupportsFormatAndModifier(format, modifier));
+                                   }
+                                   return false;
+                                 });
+
+  if (videoPlane == m_planes.end())
+  {
+    CLog::Log(LOGERROR,
+              "CDRMUtils::{} - Can not find a Video Plane plane for format {}, modifier {}",
+              __FUNCTION__, format, modifier);
+    return false;
+  }
+
+  m_video_plane = videoPlane->get();
+  CLog::Log(LOGDEBUG, "CDRMUtils::{} - using video plane {}", __FUNCTION__,
+            m_video_plane->GetPlaneId());
+
+  if (!supports_zpos || zpos_immutable)
+    return true;
+
+  // re-sort the video and gui planes
+  auto limits = m_gui_plane->GetRangePropertyLimits("zpos");
+
+  if (!limits)
+    return true;
+
+  m_gui_plane->SetProperty("zpos", limits.value()[1]);
+  m_video_plane->SetProperty("zpos", limits.value()[0]);
+  CLog::Log(LOGDEBUG, "CDRMUtils::{} - gui plane id,zpos: {}, {}", __FUNCTION__,
+            m_gui_plane->GetId(), limits.value()[1]);
+  CLog::Log(LOGDEBUG, "CDRMUtils::{} - video plane id,zpos: {}, {}", __FUNCTION__,
+            m_video_plane->GetId(), limits.value()[0]);
+
   return true;
 }
 
@@ -467,9 +520,11 @@ bool CDRMUtils::InitDrm()
   if (!FindCrtc())
     return false;
 
-  if (!FindPlanes())
+  if (!FindGuiPlane())
     return false;
 
+  FindVideoPlane(DRM_FORMAT_NV12, DRM_FORMAT_MOD_LINEAR);
+
   if (!FindPreferredMode())
     return false;
 
diff --git a/xbmc/windowing/gbm/drm/DRMUtils.h b/xbmc/windowing/gbm/drm/DRMUtils.h
index f92f716fc4..b99a6dc4fe 100644
--- a/xbmc/windowing/gbm/drm/DRMUtils.h
+++ b/xbmc/windowing/gbm/drm/DRMUtils.h
@@ -64,6 +64,8 @@ public:
   static uint32_t FourCCWithoutAlpha(uint32_t fourcc);
 
   void SetInFenceFd(int fd) { m_inFenceFd = fd; }
+  bool FindVideoPlane(uint32_t format, uint64_t modifier);
+  bool FindGuiPlane();
   int TakeOutFenceFd()
   {
     int fd{-1};
@@ -89,13 +91,13 @@ protected:
   int m_inFenceFd{-1};
   int m_outFenceFd{-1};
 
+  std::vector<std::unique_ptr<CDRMCrtc>> m_crtcs;
   std::vector<std::unique_ptr<CDRMPlane>> m_planes;
 
 private:
   bool FindConnector();
   bool FindEncoder();
   bool FindCrtc();
-  bool FindPlanes();
   bool FindPreferredMode();
   bool RestoreOriginalMode();
   RESOLUTION_INFO GetResolutionInfo(drmModeModeInfoPtr mode);
@@ -106,7 +108,6 @@ private:
 
   std::vector<std::unique_ptr<CDRMConnector>> m_connectors;
   std::vector<std::unique_ptr<CDRMEncoder>> m_encoders;
-  std::vector<std::unique_ptr<CDRMCrtc>> m_crtcs;
 };
 
 }
